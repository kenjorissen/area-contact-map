<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Area Editor</title>

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />

    <style>
      :root {
        --panel-w: 360px;
        --status-h: 0px;
      }
      html,
      body {
        height: 100%;
        margin: 0;
        font-family:
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          sans-serif;
      }
      #app {
        height: 100%;
        box-sizing: border-box;
        padding-bottom: var(--status-h);
        display: grid;
        grid-template-columns: var(--panel-w) 8px 1fr;
      }
      #panel {
        border-right: 1px solid #ddd;
        padding: 12px;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .panelHeader {
        display: flex;
        gap: 8px;
        align-items: center;
        justify-content: space-between;
        padding: 8px 10px;
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        background: #f8fafc;
        box-shadow: 0 1px 0 rgba(0, 0, 0, 0.03);
      }
      .panelHeaderActions {
        display: none;
      }
      #panelResizer {
        cursor: col-resize;
        background: linear-gradient(to right, #f2f2f2, #f7f7f7, #f2f2f2);
        border-right: 1px solid #ddd;
        border-left: 1px solid #ddd;
        touch-action: none;
      }
      #panelResizer:hover {
        background: linear-gradient(to right, #ececec, #f3f3f3, #ececec);
      }
      body.resizing {
        cursor: col-resize;
        user-select: none;
      }
      #map {
        height: 100%;
      }
      body.sidebarCollapsed #panel,
      body.sidebarCollapsed #panelResizer {
        display: none;
      }
      body.sidebarCollapsed #app {
        grid-template-columns: 1fr;
      }

      .row {
        display: grid;
        grid-template-columns: 110px 1fr;
        gap: 8px;
        align-items: center;
        margin: 8px 0;
      }
      label {
        font-size: 12px;
        color: #333;
      }
      input,
      select,
      button,
      textarea {
        font: inherit;
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 8px;
        width: 100%;
        box-sizing: border-box;
      }
      #panel button {
        padding: 5px 8px;
        font-size: 12px;
        line-height: 1.2;
      }
      textarea {
        min-height: 70px;
        resize: vertical;
      }
      button {
        cursor: pointer;
      }
      .actionRowCompact {
        margin-top: 0;
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        gap: 6px;
      }
      .actionRowCompact button {
        padding: 3px 6px;
        font-size: 11px;
        line-height: 1.15;
        border-radius: 6px;
      }
      .muted {
        color: #666;
        font-size: 12px;
        line-height: 1.35;
      }
      .hintTiny {
        color: #6b7280;
        font-size: 11px;
        line-height: 1.3;
      }
      .status {
        flex: 1 1 auto;
        min-width: 0;
        margin-top: 0;
        padding: 2px 7px;
        border-radius: 7px;
        background: #f4f4f4;
        font-size: 11px;
        color: #333;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .status.warn {
        background: #fff5e8;
        color: #7a4b00;
      }
      .panelDivider {
        height: 1px;
        background: #eee;
        margin: 12px 0;
      }
      .hidden {
        display: none;
      }
      .sidebarBody {
        flex: 1 1 auto;
        min-height: 0;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        padding-right: 2px;
        padding-bottom: 10px;
      }
      .sectionHeader {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
      }
      .sectionTitle {
        font-weight: 700;
      }
      .titleStrong {
        font-weight: 700;
      }
      .btnAutoWidth {
        width: auto;
      }
      .fileInputHidden {
        display: none;
      }
      .statusWrap {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 1000;
        margin: 0;
        box-sizing: border-box;
        background: #fafafa;
        border-top: 1px solid #ececec;
        padding: 4px 8px;
        box-shadow: 0 -1px 0 rgba(0, 0, 0, 0.03);
      }
      .statusHead {
        display: flex;
        align-items: center;
        gap: 6px;
        min-width: 0;
      }
      .statusTitle {
        font-size: 11px;
        font-weight: 700;
        letter-spacing: 0.03em;
        text-transform: uppercase;
        color: #4b5563;
      }
      .statusHint {
        font-size: 11px;
        color: #6b7280;
        white-space: nowrap;
      }
      .statusHint.clickable {
        cursor: pointer;
        text-decoration: underline;
        text-decoration-style: dotted;
        text-underline-offset: 2px;
      }
      .statusExplain {
        flex: 1 1 auto;
        min-width: 160px;
        font-size: 11px;
        color: #6b7280;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .badge {
        font-size: 11px;
        padding: 1px 6px;
        border-radius: 999px;
        border: 1px solid #ccc;
        background: #f7f7f7;
        color: #333;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .badge.pending {
        background: #fff4e5;
        border-color: #f59e0b;
        color: #92400e;
      }
      .badge.saved {
        background: #ecfdf3;
        border-color: #34d399;
        color: #166534;
      }
      .badge.clickable {
        cursor: pointer;
      }
      .btnPending {
        position: relative;
      }
      .btnPending::after {
        content: "";
        position: absolute;
        top: 6px;
        right: 6px;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #f59e0b;
        display: none;
      }
      .btnPending.pending::after {
        display: block;
      }

      .areaListSection {
        margin-top: 10px;
        flex: 1 1 auto;
        min-height: 0;
        display: flex;
        flex-direction: column;
      }
      .areaListSection input {
        margin-bottom: 8px;
        flex: 0 0 auto;
      }
      .searchRow {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 6px;
        align-items: center;
        margin-bottom: 8px;
      }
      .searchRow input {
        margin-bottom: 0;
      }
      .searchClearBtn {
        width: auto;
        min-width: 54px;
      }
      .areaListScroll {
        flex: 1 1 auto;
        min-height: 0;
        overflow-y: auto;
        padding-right: 2px;
      }
      .item {
        border: 1px solid #eee;
        border-radius: 10px;
        padding: 8px;
        margin: 8px 0;
        display: grid;
        gap: 4px;
      }
      .item.selected {
        border-color: #2563eb;
        background: #eff6ff;
        box-shadow: inset 0 0 0 1px rgba(37, 99, 235, 0.15);
      }
      .item b {
        font-size: 13px;
      }
      .pill {
        display: inline-block;
        font-size: 11px;
        padding: 2px 8px;
        border-radius: 999px;
        border: 1px solid #ddd;
        color: #444;
        width: fit-content;
      }
      .suggestModal {
        position: fixed;
        inset: 0;
        z-index: 1700;
        display: none;
        align-items: center;
        justify-content: center;
        background: rgba(2, 8, 23, 0.35);
        padding: 16px;
        box-sizing: border-box;
      }
      .suggestModal.open {
        display: flex;
      }
      .suggestModalCard {
        width: min(420px, calc(100vw - 32px));
        background: #111827;
        color: #f9fafb;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 12px;
        padding: 12px 14px;
        box-shadow: 0 16px 40px rgba(0, 0, 0, 0.35);
        font-size: 13px;
        line-height: 1.35;
      }
      .suggestModalRow {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .suggestModal .spinner {
        display: inline-block;
        width: 12px;
        height: 12px;
        border: 2px solid rgba(255, 255, 255, 0.35);
        border-top-color: #fff;
        border-radius: 50%;
        animation: suggestSpin 0.8s linear infinite;
      }
      @keyframes suggestSpin {
        from {
          transform: rotate(0deg);
        }
        to {
          transform: rotate(360deg);
        }
      }
      .toggleRow {
        display: flex;
        align-items: center;
        gap: 6px;
        margin-top: 4px;
        font-size: 11px;
        color: #374151;
      }
      .toggleRow input {
        width: auto;
        padding: 0;
      }
      .toggleGrid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 4px 8px;
        align-items: center;
      }
      .toggleGrid .toggleRow {
        margin-top: 0;
      }
      .subSection {
        margin-top: 10px;
        padding: 8px 10px;
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        background: #f8fafc;
      }
      .subSectionTitle {
        font-size: 11px;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.03em;
        color: #4b5563;
        margin-bottom: 4px;
      }
      .leaflet-tooltip.areaLabel {
        background: rgba(255, 255, 255, 0.92);
        border: 1px solid #d1d5db;
        border-radius: 6px;
        box-shadow: none;
        color: #111827;
        font-size: 11px;
        font-weight: 600;
        padding: 2px 6px;
      }
      .leaflet-tooltip.areaLabel::before {
        display: none;
      }
      .leaflet-tooltip.areaLabel.labelHidden {
        display: none;
      }
      .areaLabelSub {
        display: block;
        margin-top: 1px;
        font-size: 10px;
        font-weight: 500;
        color: #374151;
      }
      .areaLabelId {
        display: block;
        margin-top: 1px;
        font-size: 10px;
        font-weight: 700;
        color: #0f172a;
      }
      .shortcutsModal {
        position: fixed;
        inset: 0;
        z-index: 2000;
        display: none;
        align-items: center;
        justify-content: center;
        background: rgba(15, 23, 42, 0.35);
        padding: 16px;
        box-sizing: border-box;
      }
      .shortcutsModal.open {
        display: flex;
      }
      .shortcutsCard {
        width: min(520px, 100%);
        max-height: min(80vh, 640px);
        overflow: auto;
        background: #ffffff;
        border: 1px solid #e5e7eb;
        border-radius: 10px;
        box-shadow: 0 14px 36px rgba(2, 8, 23, 0.25);
        padding: 12px;
      }
      .shortcutsHead {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        margin-bottom: 8px;
      }
      .shortcutsGrid {
        display: grid;
        grid-template-columns: 86px 1fr;
        gap: 6px 10px;
        font-size: 13px;
      }
      .shortcutKey {
        display: inline-block;
        padding: 1px 6px;
        border: 1px solid #d1d5db;
        border-radius: 6px;
        background: #f8fafc;
        font-weight: 700;
        width: fit-content;
      }
      .selectedEditor {
        display: none;
      }
      .selectedEditor.drawerOpen {
        display: block;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 1300;
        width: min(420px, calc(100vw - 24px));
        max-height: calc(100vh - var(--status-h) - 24px);
        overflow: auto;
        background: #fff;
        border: 1px solid #dbe1e8;
        border-radius: 10px;
        box-shadow: 0 18px 42px rgba(2, 8, 23, 0.26);
        padding: 10px;
        box-sizing: border-box;
      }
      @media (max-width: 900px) {
        .selectedEditor.drawerOpen {
          top: auto;
          right: 0;
          left: 0;
          transform: none;
          bottom: var(--status-h);
          width: 100%;
          max-height: min(72vh, calc(100vh - var(--status-h) - 10px));
          border-radius: 12px 12px 0 0;
          box-shadow: 0 -10px 28px rgba(2, 8, 23, 0.24);
        }
      }
      .drawerHead {
        display: flex;
        align-items: center;
        justify-content: flex-start;
        gap: 8px;
        margin-bottom: 6px;
      }
      .drawerFooter {
        position: sticky;
        bottom: -10px;
        margin: 8px -10px -10px;
        padding: 8px 10px;
        border-top: 1px solid #e5e7eb;
        background: #fff;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
      }
      .drawerFooterText {
        font-size: 11px;
        color: #6b7280;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .editorBackdrop {
        position: fixed;
        inset: 0;
        z-index: 1200;
        background: rgba(2, 8, 23, 0.24);
        display: none;
      }
      .editorBackdrop.open {
        display: block;
      }
      .mobilePanelBackdrop {
        display: none;
      }
      .mobileEditAction {
        display: none;
      }
      @media (max-width: 900px) {
        #app {
          grid-template-columns: 1fr;
        }
        #panel,
        #panelResizer {
          display: none;
        }
        body.mobilePanelOpen #panel {
          display: flex;
          position: fixed;
          z-index: 1250;
          top: 8px;
          left: 8px;
          right: 8px;
          bottom: calc(var(--status-h) + 8px);
          border: 1px solid #dbe1e8;
          border-radius: 12px;
          background: #fff;
          box-shadow: 0 18px 42px rgba(2, 8, 23, 0.26);
        }
        body.mobilePanelOpen .mobilePanelBackdrop {
          display: block;
          position: fixed;
          z-index: 1090;
          inset: 0;
          background: rgba(2, 8, 23, 0.24);
        }
        .panelHeaderActions {
          display: flex;
          align-items: center;
          gap: 6px;
        }
        .statusExplain,
        .statusHint {
          display: none;
        }
        .mobileEditAction {
          display: inline-flex;
          position: fixed;
          z-index: 1080;
          left: 12px;
          right: 12px;
          bottom: calc(var(--status-h) + 12px);
          width: auto;
          justify-content: center;
          border-radius: 999px;
          border: 1px solid #d1d5db;
          background: #ffffff;
          box-shadow: 0 6px 20px rgba(2, 8, 23, 0.2);
          font-size: 14px;
          font-weight: 700;
          padding: 10px 14px;
        }
        .mobileEditAction[hidden] {
          display: none;
        }
      }
    </style>
  </head>
  <body>
    <div id="app">
      <div id="panel">
        <div class="panelHeader">
          <div>
            <div class="titleStrong">Area editor</div>
            <div class="muted">Draw areas, attach metadata, export GeoJSON.</div>
          </div>
          <div class="panelHeaderActions">
            <button id="btnCloseMobilePanel" class="btnAutoWidth" type="button">Close</button>
          </div>
        </div>

        <div class="sidebarBody">
          <div class="actionRowCompact">
            <button id="btnOpen">Import</button>
            <button id="btnExport" class="btnPending">Export</button>
            <button id="btnNew">New</button>
          </div>
          <div id="exportBehaviorHint" class="hintTiny" hidden>
            This browser downloads a new file each export (for example: areas 2, areas 3).
          </div>
          <input
            id="fileInput"
            class="fileInputHidden"
            type="file"
            accept=".json,.geojson,application/geo+json,application/json"
          />

          <div class="subSection">
            <div class="subSectionTitle">View &amp; navigation</div>
            <div class="toggleGrid">
              <label class="toggleRow" for="toggleAdvanced">
                <input id="toggleAdvanced" type="checkbox" />
                <span>Show IDs</span>
              </label>
              <label class="toggleRow" for="toggleOtherLabels">
                <input id="toggleOtherLabels" type="checkbox" checked />
                <span>Show all labels</span>
              </label>
            </div>
          </div>

          <div class="panelDivider"></div>

          <div class="sectionHeader">
            <div class="sectionTitle">Area List</div>
            <button id="btnEditSelected" class="btnAutoWidth">Edit selected</button>
          </div>
          <div class="areaListSection">
            <div class="searchRow">
              <input id="search" placeholder="Search by id/name/contact…" />
              <button id="btnClearSearch" class="searchClearBtn" type="button" hidden>Clear</button>
            </div>
            <div id="items" class="areaListScroll"></div>
          </div>
        </div>
      </div>

      <div id="panelResizer" aria-hidden="true"></div>
      <div id="map"></div>
    </div>
    <div
      id="selectedEditor"
      class="selectedEditor"
      role="dialog"
      aria-modal="true"
      aria-labelledby="selectedEditorTitle"
      aria-hidden="true"
      tabindex="-1"
    >
      <div class="drawerHead">
        <div id="selectedEditorTitle" class="sectionTitle">Selected area</div>
      </div>
      <div id="selectionFields" class="hidden">
        <div class="row hidden" id="rowAreaId">
          <label for="f_area_id">Area ID</label>
          <input id="f_area_id" placeholder="A-001" />
        </div>

        <div class="row">
          <label for="f_name">Area name</label>
          <input id="f_name" placeholder="area name" />
        </div>
        <div class="muted" id="nameSuggestHelp"></div>

        <div class="row">
          <label for="f_contact">Contact</label>
          <input id="f_contact" placeholder="contact name" />
        </div>

        <div class="row">
          <label for="f_status">Status</label>
          <select id="f_status">
            <option value="">(blank)</option>
            <option value="assigned">assigned</option>
            <option value="unassigned">unassigned</option>
            <option value="needs_backup">needs_backup</option>
            <option value="inactive">inactive</option>
          </select>
        </div>

        <div class="row">
          <label for="f_notes">Notes</label>
          <textarea id="f_notes" placeholder="Optional…"></textarea>
        </div>
      </div>
      <div class="drawerFooter">
        <div class="drawerFooterText">Edits save automatically.</div>
        <button id="btnCloseEditor" class="btnAutoWidth">Close</button>
      </div>
    </div>
    <button id="btnMobileEditSelected" class="mobileEditAction" type="button" hidden>
      Edit selected area
    </button>
    <div id="mobilePanelBackdrop" class="mobilePanelBackdrop" aria-hidden="true"></div>
    <div class="statusWrap">
      <div class="statusHead">
        <div class="statusTitle">Status</div>
        <div class="badge" id="badgeAutosave">Auto: unchanged</div>
        <div class="badge" id="badgeExport">Export: unchanged</div>
        <div class="statusExplain">
          Autosave is in-browser only. Import/Export to load/save to a file.
        </div>
        <div class="status" id="status">Status: Ready.</div>
        <div
          id="statusHintShortcuts"
          class="statusHint clickable"
          role="button"
          tabindex="0"
          aria-label="Open keyboard shortcuts"
        >
          Shortcuts: ?
        </div>
      </div>
    </div>
    <div id="editorBackdrop" class="editorBackdrop" aria-hidden="true"></div>
    <div
      id="suggestModal"
      class="suggestModal"
      aria-live="polite"
      role="dialog"
      aria-modal="true"
      aria-label="Name suggestion in progress"
    >
      <div class="suggestModalCard">
        <div class="suggestModalRow">
          <span class="spinner" aria-hidden="true"></span>
          <span id="suggestModalText">Trying Nominatim to suggest a name...</span>
        </div>
      </div>
    </div>
    <div
      id="shortcutsModal"
      class="shortcutsModal"
      role="dialog"
      aria-modal="true"
      aria-labelledby="shortcutsTitle"
      aria-hidden="true"
      tabindex="-1"
    >
      <div class="shortcutsCard">
        <div class="shortcutsHead">
          <div id="shortcutsTitle" class="titleStrong">Keyboard shortcuts</div>
          <button id="btnCloseShortcuts" class="btnAutoWidth">Close</button>
        </div>
        <div class="shortcutsGrid">
          <div><span class="shortcutKey">A</span></div>
          <div>Fit all areas</div>
          <div><span class="shortcutKey">S</span></div>
          <div>Fit selected area (map)</div>
          <div><span class="shortcutKey">B</span></div>
          <div>Toggle sidebar</div>
          <div><span class="shortcutKey">D</span></div>
          <div>Start drawing an area</div>
          <div><span class="shortcutKey">O</span></div>
          <div>Open/import file</div>
          <div><span class="shortcutKey">E</span></div>
          <div>Export GeoJSON</div>
          <div><span class="shortcutKey">/</span></div>
          <div>Focus search</div>
          <div><span class="shortcutKey">I</span></div>
          <div>Toggle Show IDs</div>
          <div><span class="shortcutKey">L</span></div>
          <div>Toggle Show all labels</div>
          <div><span class="shortcutKey">Esc</span></div>
          <div>Deselect selected area</div>
          <div><span class="shortcutKey">?</span></div>
          <div>Toggle this shortcuts panel</div>
        </div>
      </div>
    </div>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>

    <script>
      /*
       * Architecture notes (single-file app):
       * - state.* holds durable app data (selected layer, dirty flags, file/export metadata).
       * - state.ui holds UI intent only (sidebar/editor/shortcuts open, label/advanced toggles).
       * - state.runtime holds ephemeral process values (timers, queues, focus-restore refs).
       *
       * Surface model:
       * - Surfaces are "sidebar", "editor", and "shortcuts".
       * - Use isSurfaceOpen/setSurfaceOpen/toggleSurface/closeTopSurface for open-close logic.
       * - Escape closes top-most surface by policy: shortcuts -> editor -> sidebar (mobile).
       *
       * Render/event flow:
       * - Event handlers mutate state first, then call render/sync helpers.
       * - DOM classes/ARIA are outputs of state, not the source of truth.
       */
      const DEFAULT_VIEW = [44.98, -93.265];
      const DEFAULT_ZOOM = 13;
      const ONLINE_TILE_TEMPLATE = "https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png";
      const ONLINE_TILE_ATTR = "&copy; OpenStreetMap contributors &copy; CARTO";
      const AUTOSAVE_KEY = "area-editor-autosave-v1";
      const DEFAULT_GEOJSON_FILENAME = "areas.geojson";
      const PANEL_WIDTH_KEY = "area-editor-panel-width-v1";
      const AUTOSAVE_DELAY_MS = 1200;
      const GEOCODE_MIN_INTERVAL_MS = 700;
      const GEOCODE_FAILURE_BACKOFF_MS = 2200;
      const LABEL_OFFSETS = (() => {
        const offsets = [[0, 0]];
        const dirs = [
          [0, -1],
          [0, 1],
          [-1, 0],
          [1, 0],
          [-1, -1],
          [1, -1],
          [-1, 1],
          [1, 1],
          [-2, -1],
          [2, -1],
          [-2, 1],
          [2, 1],
          [-1, -2],
          [1, -2],
          [-1, 2],
          [1, 2],
        ];
        const radii = [18, 28, 40, 56, 74, 94, 116, 142];
        for (const r of radii) {
          for (const [dx, dy] of dirs) {
            const len = Math.hypot(dx, dy) || 1;
            offsets.push([Math.round((dx / len) * r), Math.round((dy / len) * r)]);
          }
        }
        return offsets;
      })();
      const STATUS_STYLE = {
        assigned: { color: "#1f7a3f", fillColor: "#2fa85a" },
        unassigned: { color: "#8a4f00", fillColor: "#d18a1b" },
        needs_backup: { color: "#92400e", fillColor: "#f59e0b" },
        inactive: { color: "#374151", fillColor: "#6b7280" },
        blank: { color: "#1d4ed8", fillColor: "#3b82f6" },
      };

      // Compatibility shim for Leaflet Draw 1.0.4 on modern Leaflet:
      // Draw's edit path still references deprecated L.LineUtil._flat.
      // Alias it to L.LineUtil.isFlat so edit mode works without console noise.
      // Safe because both are the same flat-coordinates check.
      if (L?.LineUtil?.isFlat && L?.LineUtil?._flat !== L.LineUtil.isFlat) {
        L.LineUtil._flat = L.LineUtil.isFlat;
      }

      const map = L.map("map", { preferCanvas: true });
      map.setView(DEFAULT_VIEW, DEFAULT_ZOOM);
      const panelResizer = document.getElementById("panelResizer");

      const drawnItems = new L.FeatureGroup();
      map.addLayer(drawnItems);

      const state = {
        selectedLayer: null,
        tileLayer: null,
        currentGeoJSONName: DEFAULT_GEOJSON_FILENAME,
        exportFileHandle: null,
        nextAreaIdNumber: 1,
        dirtySinceAutosave: false,
        dirtySinceExport: false,
        lastAutosaveAt: null,
        lastExportAt: null,
        ui: {
          showAdvanced: false,
          showOtherLabels: true,
          editorDrawerOpen: false,
          shortcutsOpen: false,
          sidebarOpen: true,
        },
        runtime: {
          geocodeBackoffUntil: 0,
          geocodeWarmupDone: false,
          hasSuccessfulGeocode: false,
          autosaveTimer: null,
          labelDeclutterFrame: null,
          geocodeQueue: Promise.resolve(),
          lastGeocodeAt: 0,
          restoreFocusEl: {
            editor: null,
            shortcuts: null,
          },
        },
      };
      let sidebarToggleControlEl = null;
      const mobileScreenQuery = window.matchMedia("(max-width: 900px)");
      if (mobileScreenQuery.matches) {
        state.ui.sidebarOpen = false;
      }

      const els = {
        btnOpen: document.getElementById("btnOpen"),
        btnExport: document.getElementById("btnExport"),
        btnNew: document.getElementById("btnNew"),
        btnCloseMobilePanel: document.getElementById("btnCloseMobilePanel"),
        panel: document.getElementById("panel"),
        fileInput: document.getElementById("fileInput"),
        exportBehaviorHint: document.getElementById("exportBehaviorHint"),
        statusWrap: document.querySelector(".statusWrap"),
        status: document.getElementById("status"),
        badgeAutosave: document.getElementById("badgeAutosave"),
        badgeExport: document.getElementById("badgeExport"),
        mobilePanelBackdrop: document.getElementById("mobilePanelBackdrop"),
        nameSuggestHelp: document.getElementById("nameSuggestHelp"),
        suggestModal: document.getElementById("suggestModal"),
        suggestModalText: document.getElementById("suggestModalText"),
        selectedEditor: document.getElementById("selectedEditor"),
        editorBackdrop: document.getElementById("editorBackdrop"),
        selectionFields: document.getElementById("selectionFields"),
        toggleAdvanced: document.getElementById("toggleAdvanced"),
        toggleOtherLabels: document.getElementById("toggleOtherLabels"),
        rowAreaId: document.getElementById("rowAreaId"),

        f_area_id: document.getElementById("f_area_id"),
        f_name: document.getElementById("f_name"),
        f_contact: document.getElementById("f_contact"),
        f_status: document.getElementById("f_status"),
        f_notes: document.getElementById("f_notes"),

        btnCloseEditor: document.getElementById("btnCloseEditor"),
        btnEditSelected: document.getElementById("btnEditSelected"),
        btnMobileEditSelected: document.getElementById("btnMobileEditSelected"),
        statusHintShortcuts: document.getElementById("statusHintShortcuts"),
        shortcutsModal: document.getElementById("shortcutsModal"),
        btnCloseShortcuts: document.getElementById("btnCloseShortcuts"),

        search: document.getElementById("search"),
        btnClearSearch: document.getElementById("btnClearSearch"),
        items: document.getElementById("items"),
      };

      function setStatus(msg, warn = false) {
        els.status.textContent = `Status: ${msg}`;
        els.status.classList.toggle("warn", warn);
      }

      function setSuggestModalOpen(open, text = "") {
        if (!els.suggestModal) return;
        if (open) {
          const msg = text || "Trying Nominatim to suggest a name...";
          if (els.suggestModalText) els.suggestModalText.textContent = msg;
          els.suggestModal.classList.add("open");
        } else {
          els.suggestModal.classList.remove("open");
        }
      }

      function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      async function scheduleGeocodeCall(call) {
        const run = state.runtime.geocodeQueue.then(async () => {
          const elapsed = Date.now() - state.runtime.lastGeocodeAt;
          const cooldownMs = Math.max(0, state.runtime.geocodeBackoffUntil - Date.now());
          const waitMs = Math.max(0, GEOCODE_MIN_INTERVAL_MS - elapsed, cooldownMs);
          if (waitMs > 0) await sleep(waitMs);
          try {
            return await call();
          } finally {
            state.runtime.lastGeocodeAt = Date.now();
          }
        });
        state.runtime.geocodeQueue = run.catch(() => {});
        return run;
      }

      async function ensureGeocodeWarmup() {
        if (state.runtime.geocodeWarmupDone) return;
        state.runtime.geocodeWarmupDone = true;
        try {
          await scheduleGeocodeCall(async () => {
            const ctrl = new AbortController();
            const timer = setTimeout(() => ctrl.abort(), 4500);
            try {
              await fetch(
                `https://nominatim.openstreetmap.org/reverse?format=jsonv2&zoom=18&addressdetails=1&lat=${encodeURIComponent(DEFAULT_VIEW[0])}&lon=${encodeURIComponent(DEFAULT_VIEW[1])}`,
                {
                  signal: ctrl.signal,
                  headers: { Accept: "application/json" },
                },
              );
            } finally {
              clearTimeout(timer);
            }
          });
        } catch {}
      }

      function shortRoadName(name) {
        let s = String(name || "").trim();
        if (!s) return "";
        s = s
          .replace(/[.,]/g, " ")
          .replace(/\bStreet\b/gi, "St")
          .replace(/\bAvenue\b/gi, "Ave")
          .replace(/\bRoad\b/gi, "Rd")
          .replace(/\bDrive\b/gi, "Dr")
          .replace(/\bBoulevard\b/gi, "Blvd")
          .replace(/\bPlace\b/gi, "Pl")
          .replace(/\bLane\b/gi, "Ln")
          .replace(/\bCourt\b/gi, "Ct")
          .replace(/\bTerrace\b/gi, "Ter")
          .replace(/\bParkway\b/gi, "Pkwy")
          .replace(/\bCircle\b/gi, "Cir")
          .replace(/\bHighway\b/gi, "Hwy")
          .replace(/\bTrail\b/gi, "Trl")
          .replace(/\bNorth\b/gi, "N")
          .replace(/\bSouth\b/gi, "S")
          .replace(/\bEast\b/gi, "E")
          .replace(/\bWest\b/gi, "W")
          .replace(/\b([nsew])\b/g, (m) => m.toUpperCase())
          .replace(/\s+/g, " ")
          .trim();
        return s;
      }

      function roadTypeScore(name) {
        const s = String(name || "").toLowerCase();
        if (!s) return 0;
        if (/\b(st|street)\b/.test(s)) return 2;
        if (/\b(ave|avenue)\b/.test(s)) return 1;
        return 0;
      }

      function numericPrefix(name) {
        const m = String(name || "")
          .trim()
          .match(/(?:^|\s)(\d+)(?:\b|st\b|nd\b|rd\b|th\b)/i);
        if (!m) return null;
        const n = Number.parseInt(m[1], 10);
        return Number.isFinite(n) ? n : null;
      }

      function orderedRoadPair(a, b) {
        const left = String(a || "").trim();
        const right = String(b || "").trim();
        if (!left || !right) return [left, right];
        const na = numericPrefix(left);
        const nb = numericPrefix(right);
        if (na != null && nb != null && na !== nb) {
          return na < nb ? [left, right] : [right, left];
        }
        return [left, right];
      }

      function ordinalTokenParts(token) {
        const m = String(token || "")
          .trim()
          .match(/^(\d+)(st|nd|rd|th)$/i);
        if (!m) return null;
        return { n: m[1], suffix: m[2].toLowerCase() };
      }

      function directionToken(token) {
        const t = String(token || "")
          .trim()
          .toUpperCase();
        return /^(N|S|E|W|NE|NW|SE|SW)$/.test(t) ? t : "";
      }

      function roadTypeTokenAtEnd(tokens) {
        if (!tokens.length) return "";
        const last = String(tokens[tokens.length - 1] || "");
        return /^(st|ave|rd|dr|blvd|pl|ln|ct|ter|pkwy|cir|hwy|trl)$/i.test(last) ? last : "";
      }

      function parseRoadNameParts(name) {
        const tokens = String(name || "")
          .trim()
          .split(/\s+/)
          .filter(Boolean);
        const out = {
          prefixDir: "",
          coreTokens: [],
          type: "",
          suffixDir: "",
        };
        if (!tokens.length) return out;

        const work = [...tokens];
        const firstDir = directionToken(work[0]);
        if (firstDir) {
          out.prefixDir = firstDir;
          work.shift();
        }

        const lastDir = directionToken(work[work.length - 1]);
        if (lastDir) {
          out.suffixDir = lastDir;
          work.pop();
        }

        const type = roadTypeTokenAtEnd(work);
        if (type) {
          out.type = type;
          work.pop();
        }

        out.coreTokens = work;
        return out;
      }

      function compactRoadPair(a, b) {
        const left = String(a || "").trim();
        const right = String(b || "").trim();
        if (!left || !right) return "";

        const leftParts = parseRoadNameParts(left);
        const rightParts = parseRoadNameParts(right);

        const samePrefixDir =
          leftParts.prefixDir &&
          rightParts.prefixDir &&
          leftParts.prefixDir === rightParts.prefixDir;
        const sameSuffixDir =
          leftParts.suffixDir &&
          rightParts.suffixDir &&
          leftParts.suffixDir === rightParts.suffixDir;
        const sameType =
          leftParts.type &&
          rightParts.type &&
          leftParts.type.toLowerCase() === rightParts.type.toLowerCase();

        const leftCore = [...leftParts.coreTokens];
        const rightCore = [...rightParts.coreTokens];
        const leftLast = leftCore[leftCore.length - 1] || "";
        const rightLast = rightCore[rightCore.length - 1] || "";
        const leftOrd = ordinalTokenParts(leftLast);
        const rightOrd = ordinalTokenParts(rightLast);
        if (sameType && leftOrd && rightOrd && leftOrd.suffix === rightOrd.suffix) {
          leftCore[leftCore.length - 1] = leftOrd.n;
        }

        const leftTokens = [];
        if (!samePrefixDir && leftParts.prefixDir) leftTokens.push(leftParts.prefixDir);
        leftTokens.push(...leftCore);
        if (!sameType && leftParts.type) leftTokens.push(leftParts.type);
        if (!sameSuffixDir && leftParts.suffixDir) leftTokens.push(leftParts.suffixDir);

        const rightTokens = [];
        if (!samePrefixDir && rightParts.prefixDir) rightTokens.push(rightParts.prefixDir);
        rightTokens.push(...rightCore);
        if (rightParts.type) rightTokens.push(rightParts.type);
        if (rightParts.suffixDir) rightTokens.push(rightParts.suffixDir);

        const leftText = leftTokens.join(" ").trim() || left;
        const rightText = rightTokens.join(" ").trim() || right;
        const prefixText = samePrefixDir ? `${leftParts.prefixDir} ` : "";
        return `${prefixText}${leftText}-${rightText}`;
      }

      function pairSignature(a, b) {
        const normVal = (v) =>
          String(v || "")
            .trim()
            .toLowerCase()
            .replace(/\s+/g, " ");
        return [normVal(a), normVal(b)].sort().join("||");
      }

      function firstRingLatLngs(layer) {
        const all = layer?.getLatLngs?.();
        if (!Array.isArray(all)) return [];
        let cur = all;
        while (Array.isArray(cur) && cur.length && Array.isArray(cur[0])) {
          cur = cur[0];
        }
        if (!Array.isArray(cur)) return [];
        return cur.filter((pt) => Number.isFinite(pt?.lat) && Number.isFinite(pt?.lng));
      }

      function edgeMidpointsBySide(layer) {
        const ring = firstRingLatLngs(layer);
        if (ring.length < 3) return null;
        const points = [...ring];
        const first = points[0];
        const last = points[points.length - 1];
        if (first.lat !== last.lat || first.lng !== last.lng) {
          points.push(first);
        }

        const mids = [];
        for (let i = 0; i < points.length - 1; i += 1) {
          const a = points[i];
          const b = points[i + 1];
          mids.push({ lat: (a.lat + b.lat) / 2, lng: (a.lng + b.lng) / 2 });
        }
        if (!mids.length) return null;

        let north = mids[0];
        let south = mids[0];
        let west = mids[0];
        let east = mids[0];
        for (const mid of mids) {
          if (mid.lat > north.lat) north = mid;
          if (mid.lat < south.lat) south = mid;
          if (mid.lng < west.lng) west = mid;
          if (mid.lng > east.lng) east = mid;
        }

        const distinctCount = new Set([
          `${north.lat},${north.lng}`,
          `${south.lat},${south.lng}`,
          `${west.lat},${west.lng}`,
          `${east.lat},${east.lng}`,
        ]).size;
        if (distinctCount < 3) return null;
        return { north, south, west, east };
      }

      function describeLookupError(err) {
        if (!err) return "unknown error";
        if (err.name === "AbortError") return "timeout";
        const msg = String(err.message || "").trim();
        if (/HTTP\s+429/i.test(msg)) return "HTTP 429 (rate limited)";
        if (/HTTP\s+([45]\\d\\d)/i.test(msg)) return msg;
        return msg || err.name || "unknown error";
      }

      function shouldBackoffForError(msg) {
        const m = String(msg || "").toLowerCase();
        return m.includes("429") || m.includes("failed to fetch");
      }

      async function httpErrorFromResponse(res) {
        const status = Number(res?.status || 0);
        let detail = "";
        try {
          const text = await res.clone().text();
          if (text) detail = String(text).trim();
        } catch {}
        return new Error(`HTTP ${status}${detail ? `: ${detail}` : ""}`);
      }

      function parseRoadFromNominatim(data) {
        const addr = data?.address || {};
        return shortRoadName(
          addr.road || addr.pedestrian || addr.residential || addr.footway || addr.path || "",
        );
      }

      async function reverseRoadNameFor(lat, lng, opts = {}) {
        const timeoutMs = Number.isFinite(opts.timeoutMs) ? Number(opts.timeoutMs) : 2200;
        const url = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&zoom=18&addressdetails=1&lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lng)}`;
        try {
          const data = await scheduleGeocodeCall(async () => {
            const ctrl = new AbortController();
            const timer = setTimeout(() => ctrl.abort(), timeoutMs);
            try {
              const res = await fetch(url, {
                signal: ctrl.signal,
                headers: { Accept: "application/json" },
              });
              if (!res.ok) throw await httpErrorFromResponse(res);
              return res.json();
            } finally {
              clearTimeout(timer);
            }
          });
          const road = parseRoadFromNominatim(data);
          state.runtime.geocodeBackoffUntil = 0;
          state.runtime.hasSuccessfulGeocode = true;
          return { road, error: "" };
        } catch (err) {
          const msg = describeLookupError(err);
          if (shouldBackoffForError(msg)) {
            state.runtime.geocodeBackoffUntil = Math.max(
              state.runtime.geocodeBackoffUntil,
              Date.now() + GEOCODE_FAILURE_BACKOFF_MS,
            );
          }
          return { road: "", error: msg };
        }
      }

      async function reverseRoadAt(point, opts = {}) {
        return reverseRoadNameFor(point.lat, point.lng, opts);
      }

      async function suggestAreaNameFromBoundsDetails(layer, opts = {}) {
        const reverseOpts = opts.reverseOpts || {};
        const totalBudgetMs = Number.isFinite(opts.totalBudgetMs)
          ? Number(opts.totalBudgetMs)
          : 5200;
        const startedAt = Date.now();
        const empty = {
          northRoad: "",
          southRoad: "",
          westRoad: "",
          eastRoad: "",
          northError: "",
          southError: "",
          westError: "",
          eastError: "",
          northSouth: "",
          westEast: "",
          suggested: "",
          failedPoint: "",
        };
        if (!layer || typeof layer.getBounds !== "function") return empty;
        const bounds = layer.getBounds();
        if (!bounds || !bounds.isValid()) return empty;
        const center = bounds.getCenter();
        const boundsPoints = {
          north: { lat: bounds.getNorth(), lng: center.lng },
          south: { lat: bounds.getSouth(), lng: center.lng },
          west: { lat: center.lat, lng: bounds.getWest() },
          east: { lat: center.lat, lng: bounds.getEast() },
        };
        const points = edgeMidpointsBySide(layer) || boundsPoints;

        const north = await reverseRoadAt(points.north, reverseOpts);
        const south = await reverseRoadAt(points.south, reverseOpts);
        let west = { road: "", error: "" };
        let east = { road: "", error: "" };
        if (Date.now() - startedAt < totalBudgetMs) {
          west = await reverseRoadAt(points.west, reverseOpts);
        } else {
          west.error = "skipped (time budget)";
        }
        if (Date.now() - startedAt < totalBudgetMs) {
          east = await reverseRoadAt(points.east, reverseOpts);
        } else {
          east.error = "skipped (time budget)";
        }

        const northRoad = north.road || "";
        const southRoad = south.road || "";
        const westRoad = west.road || "";
        const eastRoad = east.road || "";

        const northSouthPair = orderedRoadPair(southRoad, northRoad).filter(Boolean);
        const westEastPair = orderedRoadPair(westRoad, eastRoad).filter(Boolean);
        let northSouth =
          northSouthPair.length === 2 ? compactRoadPair(northSouthPair[0], northSouthPair[1]) : "";
        let westEast =
          westEastPair.length === 2 ? compactRoadPair(westEastPair[0], westEastPair[1]) : "";
        if (northSouth && westEast) {
          const samePair =
            pairSignature(northSouthPair[0], northSouthPair[1]) ===
            pairSignature(westEastPair[0], westEastPair[1]);
          if (samePair) {
            if (northSouth.length <= westEast.length) westEast = "";
            else northSouth = "";
          }
        }

        let suggested = "";
        if (northSouth && westEast) {
          const nsScore = roadTypeScore(northSouthPair[0]) + roadTypeScore(northSouthPair[1]);
          const weScore = roadTypeScore(westEastPair[0]) + roadTypeScore(westEastPair[1]);
          suggested =
            nsScore >= weScore ? `${northSouth}/${westEast}` : `${westEast}/${northSouth}`;
        }
        if (!suggested && northSouth) suggested = northSouth;
        if (!suggested && westEast) suggested = westEast;
        if (!suggested) {
          const roads = [northRoad, southRoad, westRoad, eastRoad].filter(Boolean);
          const uniq = Array.from(new Set(roads.map((r) => r.toLowerCase())))
            .map((k) => roads.find((r) => r.toLowerCase() === k) || "")
            .filter(Boolean);
          if (uniq.length >= 2) {
            const pair = orderedRoadPair(uniq[0], uniq[1]);
            suggested = compactRoadPair(pair[0], pair[1]) || `${pair[0]}-${pair[1]}`;
          } else if (uniq.length === 1) {
            suggested = uniq[0];
          }
        }

        return {
          northRoad,
          southRoad,
          westRoad,
          eastRoad,
          northError: north.error || "",
          southError: south.error || "",
          westError: west.error || "",
          eastError: east.error || "",
          northSouth,
          westEast,
          suggested,
          failedPoint: "",
        };
      }

      function geocodeProviderLabel() {
        return "Nominatim";
      }

      function refreshNameSuggestHelp() {
        if (!els.nameSuggestHelp) return;
        els.nameSuggestHelp.textContent =
          "New areas: auto-name via Nominatim, but edit as you wish.";
      }

      async function autoSuggestNameForNewLayer(layer) {
        const p = ensureFeatureScaffold(layer).properties;
        if (String(p.name || "").trim()) return;
        const provider = geocodeProviderLabel();
        setSuggestModalOpen(true, `Trying ${provider} to suggest a name...`);
        setStatus(`Trying ${provider} to suggest an area name...`);
        try {
          if (!state.runtime.geocodeWarmupDone) void ensureGeocodeWarmup();
          const details = await suggestAreaNameFromBoundsDetails(layer, {
            totalBudgetMs: 5200,
            reverseOpts: { timeoutMs: state.runtime.hasSuccessfulGeocode ? 1600 : 2800 },
          });
          const suggested = details.suggested || "";
          if (!suggested || String(p.name || "").trim()) {
            if (!String(p.name || "").trim()) {
              const errs = [
                details.northError,
                details.southError,
                details.westError,
                details.eastError,
              ].filter(Boolean);
              if (errs.length) {
                setStatus(
                  `No suggestion from ${provider}. Some lookups failed (${errs.length}/4). Enter a name manually.`,
                  true,
                );
              } else {
                setStatus(`No suggestion from ${provider}. Enter a name manually.`);
              }
            }
            return;
          }
          p.name = suggested;
          if (state.selectedLayer === layer && !String(els.f_name.value || "").trim()) {
            els.f_name.value = suggested;
          }
          updateLayerLabel(layer);
          refreshList();
          markDirty();
          setStatus(`Suggested name via ${provider}: ${suggested}`);
        } finally {
          setSuggestModalOpen(false);
        }
      }

      function syncFooterHeight() {
        if (!els.statusWrap) return;
        const h = Math.ceil(els.statusWrap.getBoundingClientRect().height || 0);
        document.documentElement.style.setProperty("--status-h", `${h}px`);
      }

      function fmtTs(iso) {
        if (!iso) return "never";
        const d = new Date(iso);
        if (Number.isNaN(d.getTime())) return "never";
        return d.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
      }

      function refreshSaveState() {
        const autosaveText = state.dirtySinceAutosave
          ? "Auto: pending"
          : state.lastAutosaveAt
            ? `Auto: saved ${fmtTs(state.lastAutosaveAt)}`
            : "Auto: unchanged";
        const exportText = state.dirtySinceExport
          ? "Export: pending"
          : state.lastExportAt
            ? `Export: done ${fmtTs(state.lastExportAt)}`
            : "Export: unchanged";

        els.badgeAutosave.textContent = autosaveText;
        els.badgeExport.textContent = exportText;
        els.badgeAutosave.className = `badge ${state.dirtySinceAutosave ? "pending" : "saved"}`;
        els.badgeExport.className = `badge clickable ${state.dirtySinceExport ? "pending" : "saved"}`;
        els.btnExport.textContent = state.dirtySinceExport ? "Export (unsaved)" : "Export";
        els.btnExport.classList.toggle("pending", state.dirtySinceExport);
      }

      function markDirty() {
        state.dirtySinceAutosave = true;
        state.dirtySinceExport = true;
        refreshSaveState();
        scheduleAutosave();
      }

      function markCleanFromLoad() {
        if (state.runtime.autosaveTimer) {
          clearTimeout(state.runtime.autosaveTimer);
          state.runtime.autosaveTimer = null;
        }
        state.dirtySinceAutosave = false;
        state.dirtySinceExport = false;
        refreshSaveState();
      }

      function setAdvancedMode(show) {
        state.ui.showAdvanced = !!show;
        els.rowAreaId.classList.toggle("hidden", !state.ui.showAdvanced);
        els.toggleAdvanced.checked = state.ui.showAdvanced;
        els.search.placeholder = state.ui.showAdvanced
          ? "Search by id/name/contact…"
          : "Search by name/contact…";
        refreshList();
        refreshAllLayerLabels();
      }

      function styleForFeature(f) {
        const status = (f?.properties?.status || "").toLowerCase();
        const isUnassigned = status === "unassigned" || status === "";
        const palette = STATUS_STYLE[status] || STATUS_STYLE.blank;
        return {
          color: palette.color,
          fillColor: palette.fillColor,
          weight: isUnassigned ? 4 : 2,
          fillOpacity: isUnassigned ? 0.28 : 0.2,
        };
      }

      function paletteForStatus(status) {
        return STATUS_STYLE[(status || "").toLowerCase()] || STATUS_STYLE.blank;
      }

      function hexToRgba(hex, alpha) {
        const clean = String(hex || "").replace("#", "");
        if (!/^[0-9a-fA-F]{6}$/.test(clean)) return `rgba(107,114,128,${alpha})`;
        const n = Number.parseInt(clean, 16);
        const r = (n >> 16) & 255;
        const g = (n >> 8) & 255;
        const b = n & 255;
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
      }

      function applyLayerStyle(layer) {
        const base = styleForFeature(layer.feature);
        const isSelected = state.selectedLayer === layer;
        layer.setStyle({
          ...base,
          weight: isSelected ? Math.max(base.weight + 2, 5) : base.weight,
          fillOpacity: isSelected ? Math.min(base.fillOpacity + 0.12, 0.45) : base.fillOpacity,
          dashArray: isSelected ? "6 4" : null,
        });
      }

      function labelPrimaryText(p) {
        const name = String(p?.name || "").trim();
        return name || "(unnamed)";
      }

      function labelIdText(p) {
        return areaIdValue(p);
      }

      function labelSecondaryText(p) {
        return contactValue(p);
      }

      function shouldShowContactLabel(layer) {
        return state.selectedLayer === layer || map.getZoom() >= 16;
      }

      function updateLayerLabel(layer) {
        const isSelected = state.selectedLayer === layer;
        if (!isSelected && !state.ui.showOtherLabels) {
          if (layer.getTooltip()) layer.unbindTooltip();
          return;
        }

        const p = layer.feature?.properties || {};
        const primary = labelPrimaryText(p);
        const areaId = labelIdText(p);
        const contact = labelSecondaryText(p);
        const showContact = shouldShowContactLabel(layer) && contact;
        const showId = state.ui.showAdvanced && areaId;
        const html = showContact
          ? `${escapeHtml(primary)}${showId ? `<span class="areaLabelId">${escapeHtml(areaId)}</span>` : ""}<span class="areaLabelSub">${escapeHtml(contact)}</span>`
          : `${escapeHtml(primary)}${showId ? `<span class="areaLabelId">${escapeHtml(areaId)}</span>` : ""}`;

        if (layer.getTooltip()) layer.unbindTooltip();
        layer.bindTooltip(html, {
          permanent: true,
          direction: "center",
          className: "areaLabel",
          interactive: false,
        });
        layer.openTooltip();
      }

      function refreshAllLayerLabels() {
        drawnItems.eachLayer((layer) => updateLayerLabel(layer));
        scheduleLabelDeclutter();
      }

      function rectsOverlap(a, b) {
        return !(a.right <= b.left || a.left >= b.right || a.bottom <= b.top || a.top >= b.bottom);
      }

      function overlapArea(a, b) {
        const w = Math.max(0, Math.min(a.right, b.right) - Math.max(a.left, b.left));
        const h = Math.max(0, Math.min(a.bottom, b.bottom) - Math.max(a.top, b.top));
        return w * h;
      }

      function shiftedRect(rect, dx, dy) {
        return {
          left: rect.left + dx,
          right: rect.right + dx,
          top: rect.top + dy,
          bottom: rect.bottom + dy,
        };
      }

      function outsideDistance(rect, viewport) {
        let outside = 0;
        if (rect.left < viewport.left) outside += viewport.left - rect.left;
        if (rect.right > viewport.right) outside += rect.right - viewport.right;
        if (rect.top < viewport.top) outside += viewport.top - rect.top;
        if (rect.bottom > viewport.bottom) outside += rect.bottom - viewport.bottom;
        return outside;
      }

      function layerPriority(layer) {
        if (state.selectedLayer === layer) return Number.MAX_SAFE_INTEGER;
        try {
          const b = layer.getBounds?.();
          if (!b?.isValid?.()) return 0;
          const nw = map.latLngToContainerPoint(b.getNorthWest());
          const se = map.latLngToContainerPoint(b.getSouthEast());
          return Math.abs((se.x - nw.x) * (se.y - nw.y));
        } catch {
          return 0;
        }
      }

      function runLabelDeclutter() {
        state.runtime.labelDeclutterFrame = null;
        const candidates = [];
        const viewport = map.getContainer().getBoundingClientRect();

        drawnItems.eachLayer((layer) => {
          const tip = layer.getTooltip?.();
          const el = tip?.getElement?.();
          if (!el) return;
          el.classList.remove("labelHidden");
          el.style.marginLeft = "0px";
          el.style.marginTop = "0px";
          candidates.push({
            layer,
            selected: state.selectedLayer === layer,
            rect: el.getBoundingClientRect(),
            area: Math.max(1, el.offsetWidth * el.offsetHeight),
            priority: layerPriority(layer),
            el,
          });
        });

        candidates.sort((a, b) => {
          if (a.selected !== b.selected) return a.selected ? -1 : 1;
          return b.priority - a.priority;
        });

        const kept = [];
        for (const c of candidates) {
          let best = null;
          for (const [dx, dy] of LABEL_OFFSETS) {
            const moved = shiftedRect(c.rect, dx, dy);
            let overlaps = 0;
            let overlapPixels = 0;
            for (const k of kept) {
              if (rectsOverlap(moved, k)) {
                overlaps += 1;
                overlapPixels += overlapArea(moved, k);
              }
            }
            const outside = outsideDistance(moved, viewport);
            const distance = Math.abs(dx) + Math.abs(dy);
            const score = overlaps * 4000 + overlapPixels * 2 + outside * 12 + distance;
            if (!best || score < best.score) {
              best = { dx, dy, moved, overlaps, overlapPixels, score };
              if (score === 0) break;
            }
          }
          if (!best) continue;
          c.el.style.marginLeft = `${best.dx}px`;
          c.el.style.marginTop = `${best.dy}px`;
          const hide = !c.selected && best.overlaps > 0 && best.overlapPixels > c.area * 0.4;
          c.el.classList.toggle("labelHidden", hide);
          if (!hide) kept.push(best.moved);
        }
      }

      function scheduleLabelDeclutter() {
        if (state.runtime.labelDeclutterFrame) {
          cancelAnimationFrame(state.runtime.labelDeclutterFrame);
        }
        state.runtime.labelDeclutterFrame = requestAnimationFrame(runLabelDeclutter);
      }

      function addTileLayer(urlTemplate, attributionText = "") {
        if (!urlTemplate) return;
        const cleanTemplate = urlTemplate.trim();
        if (!cleanTemplate) return;

        if (state.tileLayer) {
          map.removeLayer(state.tileLayer);
        }

        state.tileLayer = L.tileLayer(cleanTemplate, {
          maxZoom: 20,
          attribution: attributionText || "",
        });
        state.tileLayer.addTo(map);

        setStatus(`Tiles: ${cleanTemplate}`);
      }

      function setOnlineTiles() {
        addTileLayer(ONLINE_TILE_TEMPLATE, ONLINE_TILE_ATTR);
      }

      function saveAutosaveSnapshot(gj, opts = {}) {
        const payload = {
          savedAt: new Date().toISOString(),
          data: gj,
          dirtySinceExport: opts.dirtySinceExport ?? state.dirtySinceExport,
        };
        try {
          localStorage.setItem(AUTOSAVE_KEY, JSON.stringify(payload));
          state.lastAutosaveAt = payload.savedAt;
          state.dirtySinceAutosave = false;
          refreshSaveState();
          return payload;
        } catch (err) {
          const msg = String(err?.name || err?.message || "").toLowerCase();
          const isQuota = msg.includes("quota") || msg.includes("exceeded");
          setStatus(
            isQuota
              ? "Autosave failed: browser storage is full. Export to save to disk."
              : "Autosave failed due to browser storage error. Export to save to disk.",
            true,
          );
          return null;
        }
      }

      function performAutosave() {
        state.runtime.autosaveTimer = null;
        if (!state.dirtySinceAutosave) return;
        const gj = exportGeoJSON();
        saveAutosaveSnapshot(gj);
        setStatus("Autosaved to browser storage.");
      }

      function scheduleAutosave() {
        if (state.runtime.autosaveTimer) clearTimeout(state.runtime.autosaveTimer);
        state.runtime.autosaveTimer = setTimeout(performAutosave, AUTOSAVE_DELAY_MS);
      }

      addSidebarToggleControl();
      addZoomAllControl();

      L.drawLocal.draw.toolbar.buttons.polygon = "Draw a new area";
      L.drawLocal.draw.handlers.polygon.tooltip.start = "Click to start a new area";
      L.drawLocal.draw.handlers.polygon.tooltip.cont = "Click to continue the area";
      L.drawLocal.draw.handlers.polygon.tooltip.end = "Click first point to finish";
      L.drawLocal.edit.toolbar.buttons.edit = "Edit areas";
      L.drawLocal.edit.toolbar.buttons.editDisabled = "No areas to edit";
      L.drawLocal.edit.toolbar.buttons.remove = "Delete areas";
      L.drawLocal.edit.toolbar.buttons.removeDisabled = "No areas to delete";
      L.drawLocal.edit.toolbar.actions.save.title = "Save area edits";
      L.drawLocal.edit.toolbar.actions.cancel.title = "Cancel area edits";
      L.drawLocal.edit.toolbar.actions.clearAll = {
        title: "Delete all areas",
        text: "Clear all",
      };

      if (L.EditToolbar?.Delete?.prototype?.removeAllLayers) {
        const originalRemoveAllLayers = L.EditToolbar.Delete.prototype.removeAllLayers;
        L.EditToolbar.Delete.include({
          removeAllLayers() {
            const count = this._deletableLayers?.getLayers?.().length || 0;
            if (count > 0) {
              const ok = confirm(`Delete all ${count} area(s)? This cannot be undone.`);
              if (!ok) return;
            }
            return originalRemoveAllLayers.call(this);
          },
        });
      }

      const drawControl = new L.Control.Draw({
        position: "topleft",
        draw: {
          polygon: {
            allowIntersection: false,
            showArea: true,
            shapeOptions: { fillOpacity: 0.15 },
          },
          polyline: false,
          rectangle: false,
          circle: false,
          circlemarker: false,
          marker: false,
        },
        edit: { featureGroup: drawnItems },
      });
      map.addControl(drawControl);

      function setSelected(layer) {
        const prev = state.selectedLayer;
        state.selectedLayer = layer;
        if (prev && drawnItems.hasLayer(prev)) {
          applyLayerStyle(prev);
          updateLayerLabel(prev);
        }

        if (!layer) {
          setEditorDrawerOpen(false);
          els.selectionFields.classList.add("hidden");
          els.f_area_id.value = "";
          els.f_name.value = "";
          els.f_contact.value = "";
          els.f_status.value = "";
          els.f_notes.value = "";
          scheduleLabelDeclutter();
          refreshSelectionActions();
          refreshList();
          return;
        }

        const p = layer.feature?.properties || {};
        els.selectionFields.classList.remove("hidden");
        els.f_area_id.value = areaIdValue(p);
        els.f_name.value = p.name || "";
        els.f_contact.value = contactValue(p);
        els.f_status.value = p.status || "";
        els.f_notes.value = p.notes || "";
        applyLayerStyle(layer);
        updateLayerLabel(layer);
        scheduleLabelDeclutter();
        refreshSelectionActions();
        refreshList();
      }

      function ensureFeatureScaffold(layer) {
        layer.feature = layer.feature || { type: "Feature", properties: {}, geometry: null };
        layer.feature.properties = layer.feature.properties || {};
        return layer.feature;
      }

      function areaIdValue(properties) {
        return String(properties?.area_id || "").trim();
      }

      function contactValue(properties) {
        return String(properties?.contact || "").trim();
      }

      function setAreaId(properties, value) {
        const next = String(value || "").trim();
        if (next) properties.area_id = next;
        else delete properties.area_id;
      }

      function setContact(properties, value) {
        const next = String(value || "").trim();
        if (next) properties.contact = next;
        else delete properties.contact;
      }

      function parseAreaIdNumber(areaId) {
        const match = String(areaId || "")
          .trim()
          .match(/^A-(\d+)$/i);
        if (!match) return null;
        const n = Number.parseInt(match[1], 10);
        return Number.isFinite(n) ? n : null;
      }

      function existingAreaIdSet() {
        const ids = new Set();
        drawnItems.eachLayer((layer) => {
          const id = areaIdValue(layer.feature?.properties);
          if (id) ids.add(id);
        });
        return ids;
      }

      function recomputeNextAreaIdNumber() {
        let max = 0;
        drawnItems.eachLayer((layer) => {
          const n = parseAreaIdNumber(areaIdValue(layer.feature?.properties));
          if (n && n > max) max = n;
        });
        state.nextAreaIdNumber = max + 1;
      }

      function generateNextAreaId() {
        const used = existingAreaIdSet();
        let n = state.nextAreaIdNumber;
        while (used.has(`A-${String(n).padStart(4, "0")}`)) n += 1;
        state.nextAreaIdNumber = n + 1;
        return `A-${String(n).padStart(4, "0")}`;
      }

      function ensureAreaId(layer) {
        const p = ensureFeatureScaffold(layer).properties;
        if (!areaIdValue(p)) {
          setAreaId(p, generateNextAreaId());
        }
        const n = parseAreaIdNumber(areaIdValue(p));
        if (n && n >= state.nextAreaIdNumber) state.nextAreaIdNumber = n + 1;
      }

      function applyToSelected() {
        if (!state.selectedLayer) return;

        const p = ensureFeatureScaffold(state.selectedLayer).properties;
        const prevAreaId = areaIdValue(p);
        const prevName = p.name || "";
        const prevContact = contactValue(p);
        const prevStatus = p.status || "";
        const prevNotes = p.notes || "";
        const enteredAreaId = els.f_area_id.value.trim();
        if (state.ui.showAdvanced) {
          setAreaId(p, enteredAreaId || areaIdValue(p) || generateNextAreaId());
        } else if (!areaIdValue(p)) {
          setAreaId(p, generateNextAreaId());
        }
        const nextName = els.f_name.value.trim();
        const nextContact = els.f_contact.value.trim();
        const nextStatus = els.f_status.value.trim();
        const nextNotes = els.f_notes.value.trim();
        const changed =
          prevAreaId !== areaIdValue(p) ||
          prevName !== nextName ||
          prevContact !== nextContact ||
          prevStatus !== nextStatus ||
          prevNotes !== nextNotes;

        p.name = nextName;
        setContact(p, nextContact);
        p.status = nextStatus;
        p.notes = nextNotes;

        applyLayerStyle(state.selectedLayer);
        updateLayerLabel(state.selectedLayer);
        refreshList();
        if (changed) markDirty();
      }

      function zoomToSelected() {
        if (!state.selectedLayer) return;
        map.fitBounds(state.selectedLayer.getBounds(), { padding: [20, 20] });
      }

      function rememberFocusFor(key) {
        const active = document.activeElement;
        state.runtime.restoreFocusEl[key] = active instanceof HTMLElement ? active : null;
      }

      function restoreRememberedFocusFor(key) {
        const el = state.runtime.restoreFocusEl[key];
        if (el && el.isConnected && typeof el.focus === "function") {
          el.focus();
        }
        state.runtime.restoreFocusEl[key] = null;
      }

      function dialogFocusable(container) {
        if (!container) return [];
        const selector =
          'a[href], button:not([disabled]), textarea:not([disabled]), input:not([disabled]), select:not([disabled]), [tabindex]:not([tabindex="-1"])';
        return Array.from(container.querySelectorAll(selector)).filter(
          (el) => !el.hasAttribute("hidden") && !el.getAttribute("aria-hidden"),
        );
      }

      function trapDialogTab(e, container) {
        if (e.key !== "Tab") return false;
        const focusables = dialogFocusable(container);
        if (!focusables.length) return false;
        const first = focusables[0];
        const last = focusables[focusables.length - 1];
        const active = document.activeElement;
        if (e.shiftKey) {
          if (active === first || !container.contains(active)) {
            e.preventDefault();
            last.focus();
            return true;
          }
          return false;
        }
        if (active === last || !container.contains(active)) {
          e.preventDefault();
          first.focus();
          return true;
        }
        return false;
      }

      function setEditorDrawerOpen(open) {
        const next = !!open && !!state.selectedLayer;
        const wasOpen = state.ui.editorDrawerOpen;
        if (next && !wasOpen) rememberFocusFor("editor");
        if (!next && wasOpen) {
          restoreRememberedFocusFor("editor");
        }
        state.ui.editorDrawerOpen = next;
        els.selectedEditor.classList.toggle("drawerOpen", next);
        els.editorBackdrop.classList.toggle("open", next);
        els.selectedEditor.setAttribute("aria-hidden", next ? "false" : "true");
        els.editorBackdrop.setAttribute("aria-hidden", next ? "false" : "true");
        if (next) {
          requestAnimationFrame(() => {
            const focusables = dialogFocusable(els.selectedEditor);
            const target = focusables[0] || els.selectedEditor;
            if (typeof target.focus === "function") target.focus();
          });
        }
        refreshSelectionActions();
      }

      function closeEditorSafely() {
        if (state.selectedLayer) applyToSelected();
        setEditorDrawerOpen(false);
      }

      function refreshSelectionActions() {
        els.btnEditSelected.disabled = !state.selectedLayer;
        if (els.btnMobileEditSelected) {
          els.btnMobileEditSelected.hidden = !(
            isMobileLayout() &&
            state.selectedLayer &&
            !isSurfaceOpen("editor")
          );
        }
      }

      function setShortcutsModalOpen(open) {
        const isOpen = !!open;
        const wasOpen = state.ui.shortcutsOpen;
        if (isOpen && !wasOpen) rememberFocusFor("shortcuts");
        if (!isOpen && wasOpen) {
          restoreRememberedFocusFor("shortcuts");
        }
        state.ui.shortcutsOpen = isOpen;
        els.shortcutsModal.classList.toggle("open", state.ui.shortcutsOpen);
        els.shortcutsModal.setAttribute("aria-hidden", state.ui.shortcutsOpen ? "false" : "true");
        if (state.ui.shortcutsOpen) {
          requestAnimationFrame(() => {
            const focusables = dialogFocusable(els.shortcutsModal);
            const target = focusables[0] || els.shortcutsModal;
            if (typeof target.focus === "function") target.focus();
          });
        }
      }

      function zoomToAll() {
        const layers = drawnItems.getLayers();
        if (!layers.length) {
          map.setView(DEFAULT_VIEW, DEFAULT_ZOOM);
          setStatus("No areas yet. Reset to default view.");
          return;
        }
        map.fitBounds(drawnItems.getBounds(), { padding: [20, 20] });
      }

      function isMobileLayout() {
        return mobileScreenQuery.matches;
      }

      function isSurfaceOpen(surface) {
        if (surface === "editor") return !!state.ui.editorDrawerOpen;
        if (surface === "shortcuts") return !!state.ui.shortcutsOpen;
        if (surface === "sidebar") return !!state.ui.sidebarOpen;
        return false;
      }

      function isSidebarOpen() {
        return isSurfaceOpen("sidebar");
      }

      function applySidebarLayoutSideEffects() {
        if (els.mobilePanelBackdrop) {
          els.mobilePanelBackdrop.setAttribute(
            "aria-hidden",
            isMobileLayout() && isSidebarOpen() ? "false" : "true",
          );
        }
        refreshSidebarControlLabel();
        requestAnimationFrame(() => {
          map.invalidateSize({ pan: false });
          scheduleLabelDeclutter();
        });
      }

      function setMobilePanelOpen(open) {
        const next = !!open;
        if (state.ui.sidebarOpen === next) return;
        state.ui.sidebarOpen = next;
        document.body.classList.toggle("mobilePanelOpen", state.ui.sidebarOpen);
        document.body.classList.toggle("sidebarCollapsed", false);
        applySidebarLayoutSideEffects();
      }

      function setDesktopSidebarCollapsed(collapsed) {
        const next = !!collapsed;
        const open = !next;
        if (state.ui.sidebarOpen === open) return;
        state.ui.sidebarOpen = open;
        document.body.classList.toggle("mobilePanelOpen", false);
        document.body.classList.toggle("sidebarCollapsed", !state.ui.sidebarOpen);
        applySidebarLayoutSideEffects();
      }

      function setSidebarOpen(open) {
        const next = !!open;
        if (isMobileLayout()) {
          setMobilePanelOpen(next);
          return;
        }
        setDesktopSidebarCollapsed(!next);
      }

      function setSurfaceOpen(surface, open) {
        if (surface === "editor") {
          setEditorDrawerOpen(open);
          return;
        }
        if (surface === "shortcuts") {
          setShortcutsModalOpen(open);
          return;
        }
        if (surface === "sidebar") {
          setSidebarOpen(open);
        }
      }

      function toggleSurface(surface) {
        setSurfaceOpen(surface, !isSurfaceOpen(surface));
      }

      function currentTopSurface() {
        if (isSurfaceOpen("shortcuts")) return "shortcuts";
        if (isSurfaceOpen("editor")) return "editor";
        if (isMobileLayout() && isSurfaceOpen("sidebar")) return "sidebar";
        return "";
      }

      function closeTopSurface() {
        const top = currentTopSurface();
        if (!top) return false;
        if (top === "editor") {
          closeEditorSafely();
          return true;
        }
        setSurfaceOpen(top, false);
        return true;
      }

      function handleMobileLayoutChange() {
        document.body.classList.toggle("mobilePanelOpen", isMobileLayout() && isSidebarOpen());
        document.body.classList.toggle("sidebarCollapsed", !isMobileLayout() && !isSidebarOpen());
        applySidebarLayoutSideEffects();
        refreshSelectionActions();
      }

      function refreshSidebarControlLabel() {
        if (!sidebarToggleControlEl) return;
        if (isMobileLayout()) {
          const isOpen = isSidebarOpen();
          const label = isOpen ? "Close panel" : "Open panel";
          sidebarToggleControlEl.textContent = isOpen ? "X" : "☰";
          sidebarToggleControlEl.title = label;
          sidebarToggleControlEl.setAttribute("aria-label", label);
          sidebarToggleControlEl.setAttribute("aria-expanded", isOpen ? "true" : "false");
          return;
        }
        const isOpen = isSidebarOpen();
        const label = isOpen ? "Hide sidebar" : "Show sidebar";
        sidebarToggleControlEl.textContent = isOpen ? "<<" : ">>";
        sidebarToggleControlEl.title = label;
        sidebarToggleControlEl.setAttribute("aria-label", label);
        sidebarToggleControlEl.setAttribute("aria-expanded", isOpen ? "true" : "false");
      }

      function addSidebarToggleControl() {
        const SidebarToggleControl = L.Control.extend({
          onAdd() {
            const container = L.DomUtil.create("div", "leaflet-bar");
            const link = L.DomUtil.create("a", "", container);
            link.href = "#";
            link.setAttribute("role", "button");
            link.setAttribute("aria-controls", "panel");
            link.style.width = "auto";
            link.style.minWidth = "30px";
            link.style.padding = "0 8px";
            link.style.textDecoration = "none";
            link.style.fontWeight = "700";

            L.DomEvent.disableClickPropagation(container);
            L.DomEvent.on(link, "click", (e) => {
              L.DomEvent.preventDefault(e);
              toggleSurface("sidebar");
            });

            sidebarToggleControlEl = link;
            refreshSidebarControlLabel();
            requestAnimationFrame(() => {
              const corner = map?._controlCorners?.topleft;
              if (corner && corner.firstChild !== container) {
                corner.insertBefore(container, corner.firstChild);
              }
            });
            return container;
          },
          onRemove() {
            sidebarToggleControlEl = null;
          },
        });

        map.addControl(new SidebarToggleControl({ position: "topleft" }));
      }

      function addZoomAllControl() {
        const ZoomAllControl = L.Control.extend({
          onAdd() {
            const container = L.DomUtil.create("div", "leaflet-bar");
            const link = L.DomUtil.create("a", "", container);
            link.href = "#";
            link.textContent = "⤢";
            link.setAttribute("role", "button");
            link.title = "Fit all areas";
            link.setAttribute("aria-label", "Fit all areas");
            link.style.width = "30px";
            link.style.height = "30px";
            link.style.lineHeight = "30px";
            link.style.textAlign = "center";
            link.style.padding = "0";
            link.style.textDecoration = "none";
            link.style.fontWeight = "700";

            L.DomEvent.disableClickPropagation(container);
            L.DomEvent.on(link, "click", (e) => {
              L.DomEvent.preventDefault(e);
              zoomToAll();
            });

            return container;
          },
        });

        map.addControl(new ZoomAllControl({ position: "topleft" }));
      }

      function bindLayer(layer) {
        ensureFeatureScaffold(layer);
        if (!layer.feature.properties.status) layer.feature.properties.status = "unassigned";
        ensureAreaId(layer);
        applyLayerStyle(layer);
        updateLayerLabel(layer);
        layer.on("click", () => {
          setSelected(layer);
        });
        layer.on("dblclick", (e) => {
          if (e?.originalEvent) {
            L.DomEvent.preventDefault(e.originalEvent);
            L.DomEvent.stopPropagation(e.originalEvent);
          }
          L.DomEvent.stopPropagation(e);
          setSelected(layer);
          setEditorDrawerOpen(true);
        });
        drawnItems.addLayer(layer);
        scheduleLabelDeclutter();
      }

      function downloadGeoJSON(filename, gj) {
        const blob = new Blob([JSON.stringify(gj, null, 2)], { type: "application/geo+json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      }

      async function writeGeoJSONToHandle(handle, gj) {
        const writable = await handle.createWritable();
        await writable.write(JSON.stringify(gj, null, 2));
        await writable.close();
      }

      function loadAutosaveSnapshot() {
        try {
          const raw = localStorage.getItem(AUTOSAVE_KEY);
          if (!raw) return null;
          const parsed = JSON.parse(raw);
          if (parsed?.data?.type === "FeatureCollection") return parsed;
        } catch {}
        return null;
      }

      function loadGeoJSON(gj) {
        drawnItems.clearLayers();
        setSelected(null);
        state.nextAreaIdNumber = 1;
        state.lastAutosaveAt = null;
        state.lastExportAt = null;
        let missingIdCount = 0;
        for (const f of gj?.features || []) {
          const t = f?.geometry?.type;
          if ((t === "Polygon" || t === "MultiPolygon") && !areaIdValue(f?.properties)) {
            missingIdCount += 1;
          }
        }

        L.geoJSON(gj, {
          style: (feature) => styleForFeature(feature),
          onEachFeature: (_feature, lyr) => bindLayer(lyr),
          filter: (feature) => {
            const t = feature?.geometry?.type;
            return t === "Polygon" || t === "MultiPolygon";
          },
        });

        if (drawnItems.getLayers().length) {
          map.fitBounds(drawnItems.getBounds(), { padding: [20, 20] });
        } else {
          map.setView(DEFAULT_VIEW, DEFAULT_ZOOM);
        }

        recomputeNextAreaIdNumber();
        refreshList();
        markCleanFromLoad();
        if (missingIdCount > 0) {
          markDirty();
          setStatus(`Loaded data and backfilled ${missingIdCount} missing area_id value(s).`, true);
        }
      }

      function exportGeoJSON() {
        const features = [];
        drawnItems.eachLayer((layer) => {
          const gj = layer.toGeoJSON();
          const t = gj?.geometry?.type;
          if (t !== "Polygon" && t !== "MultiPolygon") return;

          const existing = layer.feature?.properties || {};
          const exported = gj.properties || {};
          gj.properties = { ...existing, ...exported };
          features.push(gj);
        });
        return { type: "FeatureCollection", features };
      }

      async function tryLoadDefaultGeoJSON() {
        if (location.protocol === "file:") {
          setStatus(
            "file:// mode: auto-load prevented by browser. Use Open GeoJSON… or run a static server.",
            true,
          );
          return false;
        }

        try {
          const filename = DEFAULT_GEOJSON_FILENAME;
          const res = await fetch(`./${filename}`, { cache: "no-store" });
          if (!res.ok) return false;
          const gj = await res.json();
          if (gj?.type !== "FeatureCollection") return false;
          loadGeoJSON(gj);
          state.currentGeoJSONName = filename;
          state.exportFileHandle = null;
          setStatus(`Loaded ./${filename}`);
          return true;
        } catch {
          return false;
        }
      }

      function norm(s) {
        return (s || "")
          .toString()
          .toLowerCase()
          .normalize("NFD")
          .replace(/[\u0300-\u036f]/g, "");
      }

      function refreshList() {
        const q = norm(els.search.value);
        const rows = [];
        let selectedRowEl = null;

        drawnItems.eachLayer((layer) => {
          const p = layer.feature?.properties || {};
          rows.push({ layer, p });
        });

        rows.sort((a, b) => areaIdValue(a.p).localeCompare(areaIdValue(b.p)));

        els.items.innerHTML = "";
        for (const { layer, p } of rows) {
          const searchParts = state.ui.showAdvanced
            ? [areaIdValue(p), p.name, contactValue(p), p.status, p.notes]
            : [p.name, contactValue(p), p.status, p.notes];
          const hay = norm(searchParts.join(" "));
          if (q && !hay.includes(q)) continue;
          const palette = paletteForStatus(p.status);
          const pillStyle = `border-color:${palette.color};color:${palette.color};background:${hexToRgba(palette.fillColor, 0.14)};`;
          const primary = state.ui.showAdvanced
            ? escapeHtml(areaIdValue(p) || "(no id)")
            : escapeHtml(p.name || "(unnamed)");
          const secondary = state.ui.showAdvanced
            ? escapeHtml(p.name || "")
            : escapeHtml(contactValue(p));
          const tertiary = state.ui.showAdvanced ? escapeHtml(contactValue(p)) : "";

          const div = document.createElement("div");
          div.className = `item ${state.selectedLayer === layer ? "selected" : ""}`;
          if (state.selectedLayer === layer) selectedRowEl = div;
          div.innerHTML = `
          <b>${primary}</b>
          <div>${secondary}</div>
          <div class="pill" style="${pillStyle}">${escapeHtml(p.status || "")}</div>
          ${tertiary ? `<div class="muted">${tertiary}</div>` : ""}
        `;
          div.addEventListener("click", () => {
            setSelected(layer);
            zoomToAll();
          });
          div.addEventListener("dblclick", () => {
            setSelected(layer);
            setEditorDrawerOpen(true);
          });
          els.items.appendChild(div);
        }
        if (selectedRowEl) {
          selectedRowEl.scrollIntoView({ block: "nearest", inline: "nearest" });
        }
      }

      function refreshSearchControls() {
        const hasQuery = String(els.search.value || "").trim().length > 0;
        els.btnClearSearch.hidden = !hasQuery;
      }

      function refreshExportBehaviorHint() {
        const supportsDirectOverwrite = !!window.showSaveFilePicker;
        if (els.exportBehaviorHint) {
          els.exportBehaviorHint.hidden = supportsDirectOverwrite;
        }
      }

      function escapeHtml(s) {
        return String(s).replace(
          /[&<>"']/g,
          (c) =>
            ({
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#39;",
            })[c],
        );
      }

      els.btnEditSelected.addEventListener("click", () => {
        if (!state.selectedLayer) return;
        setEditorDrawerOpen(true);
      });
      els.btnMobileEditSelected.addEventListener("click", () => {
        if (!state.selectedLayer) return;
        setEditorDrawerOpen(true);
      });
      els.btnCloseEditor.addEventListener("click", closeEditorSafely);
      els.editorBackdrop.addEventListener("click", () => {
        closeEditorSafely();
      });
      els.statusHintShortcuts.addEventListener("click", () => setSurfaceOpen("shortcuts", true));
      els.statusHintShortcuts.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          setSurfaceOpen("shortcuts", true);
        }
      });
      els.btnCloseShortcuts.addEventListener("click", () => setSurfaceOpen("shortcuts", false));
      els.shortcutsModal.addEventListener("click", (e) => {
        if (e.target === els.shortcutsModal) setSurfaceOpen("shortcuts", false);
      });
      els.toggleAdvanced.addEventListener("change", () =>
        setAdvancedMode(els.toggleAdvanced.checked),
      );
      els.toggleOtherLabels.addEventListener("change", () => {
        state.ui.showOtherLabels = els.toggleOtherLabels.checked;
        refreshAllLayerLabels();
      });
      els.badgeExport.title = "Click to export";

      const autoApplyFields = [els.f_area_id, els.f_name, els.f_contact, els.f_status, els.f_notes];
      for (const field of autoApplyFields) {
        const evt = field.tagName === "SELECT" ? "change" : "input";
        field.addEventListener(evt, () => {
          if (!state.selectedLayer) return;
          applyToSelected();
        });
      }

      function focusField(el) {
        if (!el) return;
        el.focus();
        if (typeof el.select === "function" && el.tagName === "INPUT") el.select();
      }

      function onEnterBlurField(e) {
        if (e.key !== "Enter") return;
        e.preventDefault();
        if (!state.selectedLayer) return;
        if (typeof e.currentTarget?.blur === "function") e.currentTarget.blur();
      }

      els.f_area_id.addEventListener("keydown", onEnterBlurField);
      els.f_name.addEventListener("keydown", onEnterBlurField);
      els.f_contact.addEventListener("keydown", onEnterBlurField);
      els.f_status.addEventListener("keydown", onEnterBlurField);

      map.on(L.Draw.Event.CREATED, (e) => {
        const layer = e.layer;
        bindLayer(layer);
        setSelected(layer);
        setSuggestModalOpen(true, "Trying Nominatim to suggest a name...");
        setStatus("Trying Nominatim to suggest an area name...");
        autoSuggestNameForNewLayer(layer)
          .catch((err) => {
            setSuggestModalOpen(false);
            const msg = String(err?.message || "Unexpected error");
            setStatus(`Name suggestion failed: ${msg}`, true);
          })
          .finally(() => {
            if (state.selectedLayer === layer) {
              setEditorDrawerOpen(true);
            }
          });
        refreshList();
        markDirty();
        scheduleLabelDeclutter();
      });

      map.on(L.Draw.Event.EDITED, () => {
        drawnItems.eachLayer((layer) => {
          updateLayerLabel(layer);
        });
        refreshList();
        markDirty();
        scheduleLabelDeclutter();
      });

      map.on(L.Draw.Event.DELETED, () => {
        if (state.selectedLayer && !drawnItems.hasLayer(state.selectedLayer)) setSelected(null);
        refreshList();
        markDirty();
        scheduleLabelDeclutter();
      });
      map.on("click", (e) => {
        const target = e?.originalEvent?.target;
        if (
          target &&
          typeof target.closest === "function" &&
          target.closest(".leaflet-interactive")
        )
          return;
        if (isMobileLayout() && isSurfaceOpen("sidebar")) {
          setSurfaceOpen("sidebar", false);
        }
        if (state.selectedLayer) setSelected(null);
      });

      els.btnOpen.addEventListener("click", () => els.fileInput.click());
      els.fileInput.addEventListener("change", async () => {
        const file = els.fileInput.files?.[0];
        if (!file) return;
        const text = await file.text();
        let gj;
        try {
          gj = JSON.parse(text);
        } catch {
          alert("Not valid JSON.");
          return;
        }

        loadGeoJSON(gj);
        state.currentGeoJSONName = file.name || DEFAULT_GEOJSON_FILENAME;
        state.exportFileHandle = null;
        saveAutosaveSnapshot(gj, { dirtySinceExport: false });
        state.dirtySinceExport = false;
        refreshSaveState();
        setStatus(`Loaded ${state.currentGeoJSONName}`);
        els.fileInput.value = "";
      });

      async function runExport() {
        const gj = exportGeoJSON();
        const supportsDirectOverwrite = !!window.showSaveFilePicker;
        try {
          if (supportsDirectOverwrite) {
            if (!state.exportFileHandle) {
              state.exportFileHandle = await window.showSaveFilePicker({
                suggestedName: state.currentGeoJSONName || DEFAULT_GEOJSON_FILENAME,
                types: [
                  {
                    description: "GeoJSON",
                    accept: { "application/geo+json": [".geojson", ".json"] },
                  },
                ],
              });
              if (state.exportFileHandle?.name) {
                state.currentGeoJSONName = state.exportFileHandle.name;
              }
            }

            await writeGeoJSONToHandle(state.exportFileHandle, gj);
            state.lastExportAt = new Date().toISOString();
            state.dirtySinceExport = false;
            saveAutosaveSnapshot(gj, { dirtySinceExport: false });
            refreshSaveState();
            setStatus(`Exported and overwrote ${state.currentGeoJSONName}.`);
            return;
          }
        } catch (err) {
          if (err?.name === "AbortError") {
            setStatus("Export canceled.");
            refreshSaveState();
            return;
          }
          state.exportFileHandle = null;
          setStatus("Direct overwrite failed, downloaded file instead.", true);
        }

        const needsDownloadConfirm = !supportsDirectOverwrite && !!state.lastExportAt;
        if (needsDownloadConfirm) {
          const ok = confirm(
            "This browser cannot overwrite an existing file. Export will download a new copy. Continue?",
          );
          if (!ok) {
            setStatus("Export canceled.");
            refreshSaveState();
            return;
          }
        }

        downloadGeoJSON(state.currentGeoJSONName || DEFAULT_GEOJSON_FILENAME, gj);
        state.lastExportAt = new Date().toISOString();
        state.dirtySinceExport = false;
        saveAutosaveSnapshot(gj, { dirtySinceExport: false });
        refreshSaveState();
        setStatus("Exported GeoJSON (download).");
      }

      els.btnExport.addEventListener("click", runExport);
      els.badgeExport.addEventListener("click", runExport);
      els.btnCloseMobilePanel.addEventListener("click", () => setSurfaceOpen("sidebar", false));
      els.mobilePanelBackdrop.addEventListener("click", () => setSurfaceOpen("sidebar", false));

      els.btnNew.addEventListener("click", () => {
        if (!confirm("Clear everything and start a new empty map?")) return;
        drawnItems.clearLayers();
        state.nextAreaIdNumber = 1;
        setSelected(null);
        refreshList();
        markDirty();
        setStatus("Started new empty map.");
      });

      els.search.addEventListener("input", () => {
        refreshSearchControls();
        refreshList();
      });
      els.btnClearSearch.addEventListener("click", () => {
        if (!els.search.value) return;
        els.search.value = "";
        refreshSearchControls();
        refreshList();
        focusField(els.search);
      });
      document.addEventListener("keydown", (e) => {
        if (isSurfaceOpen("shortcuts") && trapDialogTab(e, els.shortcutsModal)) return;
        if (isSurfaceOpen("editor") && trapDialogTab(e, els.selectedEditor)) return;
        const target = e.target;
        const tag = target?.tagName;
        const isTypingTarget =
          tag === "INPUT" || tag === "TEXTAREA" || tag === "SELECT" || target?.isContentEditable;
        if (isTypingTarget) return;
        if (e.metaKey || e.ctrlKey || e.altKey) return;
        const key = (e.key || "").toLowerCase();

        if (e.key === "?") {
          e.preventDefault();
          toggleSurface("shortcuts");
          return;
        }
        if (e.key === "Escape") {
          if (closeTopSurface()) return;
          if (state.selectedLayer) setSelected(null);
          return;
        }
        if (isSurfaceOpen("shortcuts")) return;
        if (e.key === "Enter" && state.selectedLayer && !isSurfaceOpen("editor")) {
          setEditorDrawerOpen(true);
          return;
        }
        if (key === "a") {
          zoomToAll();
          return;
        }
        if (key === "s") {
          zoomToSelected();
          return;
        }
        if (key === "b") {
          toggleSurface("sidebar");
          return;
        }
        if (key === "o") {
          els.fileInput.click();
          return;
        }
        if (key === "e") {
          void runExport();
          return;
        }
        if (e.key === "/") {
          e.preventDefault();
          focusField(els.search);
          return;
        }
        if (key === "d") {
          new L.Draw.Polygon(map, drawControl.options.draw.polygon).enable();
          return;
        }
        if (key === "i") {
          els.toggleAdvanced.checked = !els.toggleAdvanced.checked;
          setAdvancedMode(els.toggleAdvanced.checked);
          return;
        }
        if (key === "l") {
          els.toggleOtherLabels.checked = !els.toggleOtherLabels.checked;
          state.ui.showOtherLabels = els.toggleOtherLabels.checked;
          refreshAllLayerLabels();
        }
      });
      setSelected(null);
      setAdvancedMode(false);
      refreshNameSuggestHelp();
      refreshSearchControls();
      refreshExportBehaviorHint();
      refreshSaveState();
      syncFooterHeight();
      window.addEventListener("resize", syncFooterHeight);
      if (typeof ResizeObserver !== "undefined") {
        const footerObserver = new ResizeObserver(() => syncFooterHeight());
        footerObserver.observe(els.statusWrap);
      }
      if (typeof mobileScreenQuery.addEventListener === "function") {
        mobileScreenQuery.addEventListener("change", handleMobileLayoutChange);
      } else if (typeof mobileScreenQuery.addListener === "function") {
        mobileScreenQuery.addListener(handleMobileLayoutChange);
      }
      handleMobileLayoutChange();
      map.on("zoomend", refreshAllLayerLabels);
      map.on("moveend", scheduleLabelDeclutter);

      setOnlineTiles();
      setStatus(`Geocoder: ${geocodeProviderLabel()}.`);

      function initPanelResize() {
        if (!panelResizer) return;
        const minW = 280;
        const minMapW = 320;
        let dragging = false;

        function widthFromPointer(clientX) {
          const appRect = document.getElementById("app").getBoundingClientRect();
          const next = clientX - appRect.left;
          const maxW = Math.max(minW, Math.round(appRect.width - minMapW));
          return Math.max(minW, Math.min(maxW, Math.round(next)));
        }

        function applyWidth(nextWidth) {
          document.documentElement.style.setProperty("--panel-w", `${nextWidth}px`);
        }

        function restoreWidth() {
          try {
            const raw = localStorage.getItem(PANEL_WIDTH_KEY);
            const parsed = Number.parseInt(String(raw || ""), 10);
            if (!Number.isFinite(parsed)) return;
            const appRect = document.getElementById("app").getBoundingClientRect();
            const maxW = Math.max(minW, Math.round(appRect.width - minMapW));
            applyWidth(Math.max(minW, Math.min(maxW, parsed)));
            map.invalidateSize({ pan: false });
          } catch {}
        }

        panelResizer.addEventListener("pointerdown", (e) => {
          dragging = true;
          panelResizer.setPointerCapture(e.pointerId);
          document.body.classList.add("resizing");
          applyWidth(widthFromPointer(e.clientX));
        });

        panelResizer.addEventListener("pointermove", (e) => {
          if (!dragging) return;
          applyWidth(widthFromPointer(e.clientX));
          map.invalidateSize({ pan: false });
        });

        function stopDrag() {
          if (!dragging) return;
          dragging = false;
          document.body.classList.remove("resizing");
          const computed = getComputedStyle(document.documentElement)
            .getPropertyValue("--panel-w")
            .trim();
          try {
            localStorage.setItem(PANEL_WIDTH_KEY, computed);
          } catch {}
          map.invalidateSize({ pan: false });
        }

        panelResizer.addEventListener("pointerup", stopDrag);
        panelResizer.addEventListener("pointercancel", stopDrag);
        panelResizer.addEventListener("lostpointercapture", stopDrag);
        restoreWidth();
      }

      initPanelResize();
      (async () => {
        const autosave = loadAutosaveSnapshot();
        if (autosave?.data?.type === "FeatureCollection") {
          loadGeoJSON(autosave.data);
          state.lastAutosaveAt = autosave.savedAt || null;
          state.dirtySinceAutosave = false;
          state.dirtySinceExport = autosave.dirtySinceExport ?? true;
          refreshSaveState();
          if (state.dirtySinceExport) {
            setStatus(
              `Loaded browser autosave from ${autosave.savedAt}. Export still pending.`,
              true,
            );
          } else {
            setStatus(`Loaded browser autosave from ${autosave.savedAt}.`, true);
          }
          return;
        }

        await tryLoadDefaultGeoJSON();
      })();
    </script>
  </body>
</html>
